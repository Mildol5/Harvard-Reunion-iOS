#import "KGOCalendarGroup.h"
#import "KGOEvent.h"
#import "KGOCalendar.h"
#import "CoreDataManager.h"
#import "Foundation+KGOAdditions.h"

NSString * const KGOEntityNameCalendarGroup = @"KGOCalendarGroup";

@implementation KGOCalendarGroup
@dynamic identifier;
@dynamic title;
@dynamic calendars;
@dynamic sortOrder;


+ (KGOCalendarGroup *)groupWithDictionary:(NSDictionary *)aDict
{
    KGOCalendarGroup *group = nil;
    NSString *identifier = [aDict stringForKey:@"id" nilIfEmpty:YES];
    if (identifier) {
        group = [KGOCalendarGroup groupWithID:identifier];
        
        NSString *title = [aDict stringForKey:@"title" nilIfEmpty:YES];
        if (![group.title isEqualToString:title]) {
            group.title = title;
        }
        
        // TODO: may want the API to report types individually per calendars
        // rather than assume all calendars are the same type within
        // a group (even if the mobile web ends up having to be that way)
        NSString *type = [aDict stringForKey:@"type" nilIfEmpty:YES];
        
        NSArray *calendars = [aDict arrayForKey:@"calendars"];
        if (calendars.count) {
            for (NSString *calendarID in calendars) {
                KGOCalendar *aCategory = [KGOCalendar categoryWithID:calendarID];
                if (![group.calendars containsObject:aCategory]) {
                    [group addCalendarsObject:aCategory];
                }
                if (![aCategory.type isEqualToString:type]) {
                    aCategory.type = type;
                }
            }
        }
    }
    
    return group;
}

+ (KGOCalendarGroup *)groupWithID:(NSString *)identifier
{
    NSPredicate *pred = [NSPredicate predicateWithFormat:@"identifier like %@", identifier];
    KGOCalendarGroup *group = [[[CoreDataManager sharedManager] objectsForEntity:KGOEntityNameCalendarGroup
                                                               matchingPredicate:pred] lastObject];
    if (!group) {
        group = [[CoreDataManager sharedManager] insertNewObjectForEntityForName:KGOEntityNameCalendarGroup];
        group.identifier = identifier;
    }
    
    return group;
}

#pragma mark - Core data autogenerated methods


- (void)addCalendarsObject:(KGOCalendar *)value {    
    NSSet *changedObjects = [[NSSet alloc] initWithObjects:&value count:1];
    [self willChangeValueForKey:@"calendars" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
    [[self primitiveValueForKey:@"calendars"] addObject:value];
    [self didChangeValueForKey:@"calendars" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
    [changedObjects release];
}

- (void)removeCalendarsObject:(KGOCalendar *)value {
    NSSet *changedObjects = [[NSSet alloc] initWithObjects:&value count:1];
    [self willChangeValueForKey:@"calendars" withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
    [[self primitiveValueForKey:@"calendars"] removeObject:value];
    [self didChangeValueForKey:@"calendars" withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
    [changedObjects release];
}

- (void)addCalendars:(NSSet *)value {    
    [self willChangeValueForKey:@"calendars" withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
    [[self primitiveValueForKey:@"calendars"] unionSet:value];
    [self didChangeValueForKey:@"calendars" withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
}

- (void)removeCalendars:(NSSet *)value {
    [self willChangeValueForKey:@"calendars" withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
    [[self primitiveValueForKey:@"calendars"] minusSet:value];
    [self didChangeValueForKey:@"calendars" withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
}


@end
